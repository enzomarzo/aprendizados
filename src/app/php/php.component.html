<h1>PHP</h1>

<h2>Porque surgiu o PHP</h2>

<p>A internet surge em 1970. E a web em 1990. Em 1995 um cara (Rasmus Lerdorf) se perguntou: como eu faço para saber quantas pessoas estão visitando meu site? E ele criou um código em C (que era a linguagem que ele manjava) para fazer isso. E deu o nome disso de ´Personal Home Page Tools´. E é dai que vem o PHP, das iniciais de Personal Home Page. Na segunda versão ele criou funcionalidade novas (em Perl) que interpretava formulários (naquela epoca muito dificil). Na versão 2 o PHP era apenas uma biblioteca e ainda não era uma linguagem. Logo depois ele resolve tornar o PHP open source e em 1997, o PHP começa a ser utilizado por muita gente e muito programador ajuda a criar novas funcionalidades. E em 1998 dois programadores israelenses resolvem remodelar todo o PHP e ai ele vira de fato uma linguagem. E renomearam a linguagem para PHP Hypertext Preprocessor. Meio estranho porque o primeiro P do PHP significa PHP !!! Mas isso porque o nome PHP já estava em alta e não valia a pena mudar. E em 1999, na sua terceira versão, já se estimava que o PHP representava 10% de toda internet </p>

<h2>Olá Mundo em PHP</h2>

<p><code>Echo "Olá mundo!";</code>. É tão simples quanto isso para escrever nosso olá mundo.</p>

<p>Para iniciar um arquivo php colocamos o <code>&lt;? php</code>. Após isso um espaço (geralmente efetua-se a quebra de linha) é obrigatório e informa ao interpretador que esse código deve ser lido e interpretado.</p>

<p>As variáveis em php começam com $.</p>

<p><b>Operações matemáticas</b> segue o padrão normal das linguagens.</p>

<p><b>Tipos</b> também seguem o padrão normal (string, float/double, integer, boolean). No PHP não há necessidade de tipar as variáveis (tipagem fraca) e conseguimos descobrir o tipo com o código <code>echo gettype($variavel)</code></p>

<p><b>String:</b> o php entende aspas simples e dupla para string. Mas as aspas duplas é mais utilizada pois ao utilizar aspas duplas o php permite que coloquemos as variáveis dentro da string (o que tiver $ será lido como variável) e também os caracteres especiais com a contra barra \ . Essas 'sequencias de escapes' podemos encontrar <a href="https://www.php.net/manual/pt_BR/language.types.string.php#language.types.string.syntax.double">na documentação do php</a></p>

<p><b>Operadores</b> lógicos (&&, ||) e de comparação (&lt; , >, == , !=) também seguem o padrão</p>

<p>Abaixo um exemplo de código simples de php com valor ternário</p>

<pre><code [highlight]='codePhp1'></code></pre>

<p><b>Composer</b>: É uma ferramneta para gerenciamento de dependências do PHP. É como o NPM do Node/JS ou o Maven no Java. Inclusive o Composer teve uma inspiração no NPM. O que ele faz é facilitar a instalação de biliotecas ou pacote de terceiros no nosso projeto.</p>

<p>O composer instala os pacotes em uma pasta chamada <b>Vendor</b>. </p>

<p><b>Array:</b> As 'listas' no php tb são como o padrão de outras linguagens - <code>$idadeList = [21, 25, 30, 35]</code> que é a mesma coisa que fazer <code>$idade1=21 ; $idade1=25 ; $idade1=30 ; $idade1=35 ;</code>. E o for com array que sempre é muito comum => <code>for($i = 0 ; $i &lt; count($idadeList); $i++ &#123;echo $idadeList[$i]&#125;	</code></p>

<p>Listas e iterações são muito utilizadas. As listas, que são conhecidas como arrays, servem para agruparmos em uma mesma variável uma serie de elementos. </p>

<h2>Adicionando itens no array</h2>

<p>Uma forma de adicionar itens no array:</p>

<p>O PHP trabalha com arrays dinamicos, então para adicionar um novo item ao array não é necessário criar uma nova lista ou manipular a memória.</p>

<pre><code [highlight]='codePhp2'></code></pre>

<h2>Arrays Associativos</h2>

<p>Me pareceu um tanto estranho quando eu vi esse ´array associativo´. Me parece algo como um objeto</p>

<pre><code [highlight]='codePhp3'></code></pre>

<p>Como o array no PHP é dinâmico e aceita string e numeros como seus indices, isso dá muito poder pros arrays. Mas não devemos usar arrays quando faz mais sentido usar objetos, senão muita coisa acaba sendo tratada como array mesmo não sendo a melhor forma.</p>

<h2>Function</h2>

<p>As funções são declaradas como no JS <code>function nome($parametro) &#123; codigo &#125;</code>. É interessante entender que o motivo de criar uma função é não precisar repetir código. Criamos uma função para poder chamá-la em vários lugares do meu código.</p>

<p>E o <code>return</code> para que serve? Para quando eu chamar essa função em algum lugar do meu código, ela retornar algum valor. Sem return, ela apenas executa a função mas não retorna nada.</p>

<p>Isso é até conceitual. Quando não retorna nada, apenas executa, chamamos de 'subrotinas' e quando retorna algo chamaos de função. No php as duas coisas são declaradas como function. Mas tem linguagens que faz essa separação.</p>

<h2>Include e Require</h2>

<p>Temos uma função e queremos acessar essa função em outro arquivo. Para isso incluimos o <code>include 'nomeComponente.php'</code>. Só que se esse arquivo não for encontrado o include permite continuar a execução. Para evitarmos que o programa continue e já nos avise sobre o erro, incluimos o <code>require 'nomeComponente.php</code> </p>

<h2>Warning x Notice x Error </h2>

<p>O php tem várias trativas de erros. Os principais são esses três. O Warning é quando o php percebe alguma coisa estranha mas consegue continuar executando o código. O Notice é quando o php dá um jeito de resolver o código (por exemplo quando tenta acessar algum item do array, não encontra e retorna nulo). O error é quando ele não consegue executar.</p>

<h2>Passagem de parametro por valor ou por referencia</h2>

<p>Dificilmente se aconselha a passar um parametro por referência. Isso porque quando fazemos isso estamos passando a variável original no parametro e, portanto, ela será modificada na nova função que estamos chamando. Para fazer isso, ao invés de fazer <code>conta ($titular)</code> que é uma passagme por valor, fazemos <code>conta (&$titular)</code>com o & na frente da variável.</p>

<h2>List => Pegando os valores de um array</h2>

<pre><code [highlight]='codePhp4'></code></pre>

<h2>Unset => Removendo uma variável</h2>

<p>Ao fazer <code>unset($variavel)</code> ou <code>unset($array[2])</code> estaremos removendo essa variável da memória.</p>

<h2>subindo em localhost (servidor local)</h2>

<p>é só digitar, no terminal, <code>php -S localhos:8000</code> ou a porta que eu quiser</p>

<p>Pronto, é só fazer isso que ele vai abrir no navegador nosso código, procurando pelo index.php</p>

<h2>PHP e HTML</h2>

<p>Como o PHP foi projetado para web, a inserção de HTML no código PHP é bem simples. Finalizamos a escrita de php com ?> e podemos escrever o que quiser após isso, inclusive HTML.</p>

<pre><code [highlight]='codePhp5'></code></pre>

<h2>MbString</h2>

<p>string é string, pra que mbstring? Perá lá, vamos entender melhor...</p>

<pre><code [highlight]='codePhp6'></code></pre>

<p>'AçUCAR E LIMãO' ficou meio estranho né? Porque o 'ç' e o 'ã' ficaram em minusculas? E porque a contagem da string foi 16 se deveria ser 14. O que acontece aqui, embaixo dos panos, é que o PHP está lendo bytes e não as letras em si. E cada caracter ´normal´ conta como 1 byte. Os caracteres especiais como 'ç' e 'ã' contam como 2 bytes. Isso é conhecido como <b><a href="https://www.php.net/manual/pt_BR/book.mbstring.php"></a>caracter multibyte</b></p>

<p>Para resolver esse problema o PHP tem uma extensão chamada de mb (que é de multibyte). Para usá-la temos que habilitar essa extensão no nosso computador (ou servidor).</p>

<pre><code [highlight]='codePhp7'></code></pre>

<h2>Programação Procedural x Orientada a Objeto</h2>

<p>Eu aprendi Orientação à Objeto com o verboso <b>Java</b>. Apesar de não ter aplicado o Java em nenhum projeto, foi com ele que eu entendi o que é a POO. E como foi a minha primeira interação com uma linguagem eu me familiarizei tanto com OO que eu não entendia muito bem como daria pra ser diferente disso</p>

<p>A programação procedural (ou programação procedimental ou até programação imperativa) é baseada em rotinas/funções. O grande avanço da orientação à objeto foi fazer com que o código fique mais fácil de dar manutenção, mais legível e reutilizável. O trade off é que precisamos criar modelagens e a curva de aprendizado é um pouco maior que a programação procedural. Criamos classes para tudo, com atributos e métodos dentro das classes. E essas classes são apenas modelos, elas por si só não executam nada. Para se tornar um objeto real temos que instanciá-las em algum momento.</p>

<p>Isso significa que dá pra programar a mesma coisa com os dois paradgimas. E na programação procedural existem atributos e métodos, mas que possivelmente podem estar em locais diferentes do código (e não dentro de uma classe como no OO).</p>

<p>O PHP em seu inicio não foi modelado com o paradigma de orientação a objeto. Ele começou a suportar orientação a objeto na versão 3. Diferente do Java que tudo gira em torno do POO.</p>

<h5>Guardando dados por valor x por referencia</h5>

<p>Quando criamos um objeto em PHP o seus dados são guardados em uma referencia. Isso é um pouco confuso, mas ao criamos um objeto e guardamos em uma instância $a, ela não será armazenada na instância $a. E sim a um objeto de uma classe no qual essa instância $a se refere</p>

<p>Bem confuso. Mas isso significa, na prática, que se ao criar uma variável $b = $a, se eu mudar a variável $b também será mudada a variável $a, pois as duas apontam pra mesma referência. E isso não é verdade quando criamos uma variável que não é um objeto, por exemplo, $c = (int) 10. Se criarmos uma variável $d = $c e mudarmos a variável $d = (int) 12, a variável $c continua valendo 10.</p>

<h3>Early Return</h3>

<p>Esse conceito é interessante. É sobre melhorar o código e sobre escrever <b>menos elses</b>. Tem gente que acredita inclusive que não se deve escrever ´else´ ;).</p>

<p>A principio isso me cheira como uma ´gambiarra´. Isso porque criamos uma função do tipo <code>void</code> (que não tem retorno). E digitamos o <code>return</code> para que a função acabe ali. Ou seja, o retornar tem o sentido de ´parar´ de executar.</p>

<p>vejamos exemplo:</p>

<pre><code [highlight]='codePhp9'></code></pre>

<pre><code [highlight]='codePhp10'></code></pre>

<p>Alguns conceitos importantes de OO</p>
<ul style="list-style-type: none;">
  <li><b>Abstração:</b> trazer o mundo real mais pra perto da programação. Objetos com propriedade e métodos. Uma pessoa tem altura e peso (ou seja, propriedades). Essa pessoa anda, corre e pula (os métodos)</li>
  <li><b>Encapsulamento:</b> muitas vezes é importante chamar um método de um objeto sem precisarmos entender a fundo o que ele faz. Então quando chamamos o pessoa.pula() não precisamos entender tudo o que é feito dentro do sistema nervoso para a pessoa pular. Precisamos saber apenas que a pessoa pula. Quando apertamos o botão de um controle não precisamos saber tudo que acontece por trás.</li>
  <li><b>Herança:</b> evita duplicar codigo é um dos mantras da orientação a objeto. E não apenas para facilitar a escrita, evitar duplicação facilita a leitura e a manutenção. Pessoas herdam caracteristas de mamiferos que herdam caracteristicas de animais. <ul><li> Apenas como complemento, há que se tomar cuidado com tanta herança, o Paulo da Alura/Caelum publicou um post lá em 2006 citando outro post que ficou famoso em 1986 do problema em usar herança só pra economizar escrita de código (o exemplo que ele é deu é que, por exemplo, cachorro herda gato porque, por exemplo, a classe gato anda e tem patas) <a href="https://blog.caelum.com.br/como-nao-aprender-orientacao-a-objetos-heranca/">link do post</a>. </li></ul></li>
  <li><b>Polimorfismo:</b> Uma pessoa é uma pessoa e também é um animal. Um gerente é um gerente e também é um funcionário. Podemos classificar esse gerente das duas formas - como gerente e como funcionário, a depender do que esteja me referindo. As vezes, para dizer que ele vai evoluir na empresa, classificamos (tipamos) ele como funcionário, assim podemos mudá-lo futuramente para diretor.</li>
</ul>

<p>A Herança também ajuda a quebrar diversos <b>ifs</b> em uma classe que possa ficar monstruosa. Imagine o mesmo cenário de ter uma classe funcionários. Poderiamos só ter uma classe funcionários e nele colocar 'if' o funcionário for Gerente, bonificar tanto. 'if' for diretor bonificar tanto. E cada método que criarmos precisaremos de ifs, como um método para aprovação, 'if' diretor aprova acima de 20 mil, 'if' gerente aprova acima de.. </p>

<h3>Static</h3>

<p>imagine que eu tenha uma classe que cria contas de banco e que eu quero contar quantas contas foram criadas (sem precisar ir ao banco de dados):</p>

<pre><code [highlight]='codePhp11'></code></pre>

<p>No caso acima o atributo esta publico, então eu ou alguém que estivesse programando poderia fazer numeroDeContas = 10. E queremos evitar que isso seja possível. Para resolver essa burocratização saúdavel transformamos o atributo em <code>private static $numeroDeContas</code> e criamos um método static <code>public static function recuperarNumeroDeContas() { return Conta::$numeroDeContas }</code></p>

<p>E no PHP ao invés de chamar pelo nome da classe como nesse caso <code>Conta::$numeroDeContas</code> eu poderia chamar pelo <code>self</code>. Ficaria então <code>self::$numeroDeContas</code>. Tanto faz!</p>

<p>Uma observação importante é que atributos/métodos estáticos devem ser criados apenas quando necessário. Muitos métodos estáticos prejudicam a testabilidade do projeto e em um projeto não é (ou não deveria ser) tão comum seu uso.</p>

<h3>Imutabilidade</h3>

<p>Um atributo da minha conta é o CPF. E quando uma pessoa cria uma conta em meu banco ela não pode mais mudar o CPF. Portanto esse atributo CPF é imutável. Para fazer isso eu coloco o atributo como privado <code>private string $CPF;</code> e <b>não crio Setters</b>. Então se o método é inacessível e se nao tem uma forma de 'settar' esse atributo não há formas de mudar esse CPF.</p>

<h3>Herança</h3>

<p>já coloquei acima que Herança e Polimorfimo é uma das principais características de Orientação a Objeto.</p>

<p>Eu vou tentar explicar sobre henrança sem colocar código</p>

<p>Vamos supor que eu esteja criando um Banco. E nesse banco eu tenha Conta Corrente, Conta Poupança e Conta Salário. Todas elas são parecidas, mas não iguais. Não faz muito sentido eu criar três classes que tenha um monte de atributo e método iguais né? Por exemplo, o atributo agência, número da Conta, Titular e os métodos sacar, depositar e transferir seriam iguals. Para não ter toda essa repetição de código, podemos dizer que Conta Poupança e Conta Salário extends da Conta Corrente. Ou seja, elas herdam as caracteristicas da Conta Corrente</p>

<p>Muito mais simples, não? Só digitar <code>ContaPoupanca extends ContaCorrente</code> que eu sei que ContaPoupanca vai conter tudo que contem Conta Corrente. E se eu quiser implementar outros atributos e métodos, é só digitar esses casos específicos.</p>

<p>Agora vamos imaginar que a Conta Popupança tenha um custo de transferência menor que a ContaCorrente. Para isso é só sobrescrever o método <b>transferir</b>.</p>

<p>Mas ainda fica estranho ContaPoupanca estender de ContaCorrente já que são duas coisas diferentes. Não parece muito 'pai e filho'. Parece mais irmãos </p>

<p>É aí que entra o <code>abstract</code>. Criamos uma classe <b>abstrata</b>. É um pouco confuso porque a 'classe' em si já é uma abstração. Nós instanciamos a classe que vai se tornar um objeto. E a classe abstrata é uma abastração ainda maior (abstração da abstração). Porque a classe abstrata não vira um objeto. Ou seja, é impossível criar uma 'Conta'. A pessoa tem que criar uma conta corrente, poupança ou salário. Só 'Conta' não existe. A Classe Conta serve como ´molde´ das classes não abstratas.</p>

<p>E além de classes abstratas, existem os métodos abstratos. Eles servem pra dizer 'meus filhos, vocês são obrigados a implementar esse método aqui'.</p>

<p><code>abstract protected function taxaSaque(): float;</code> E nem é preciso colocar as chaves/bloco do método. Ou seja, não precisamos implementar o método. Apenas colocar o nome dele e se possível o retorno que ele deve ter.</p>

<p>Se uma classe tiver métodos abstratos ela precisa ser uma classe abstrata. Porém uma classe abstrata não é obrigatório que tenha um ou todos seus métodos abastratos.</p>

<h2>Interfaces</h2>

<p>Na herança você consegue criar classes filhas facilmente. É possível herdar de classes abstratas e de classes concretas. Em classes abstratas você consegue criar atributos e métodos de tudo quanto é jeito, public, protected e abstrato.</p>

<p>As interfaces só podem ter métodos abstratos (não tem nem atributos). Ou seja, todas as classes filhas de interfaces tem que usar/recriar/fazer seus métodos. Algumas pessoas utilizam como um 'contrato'. Então por exemplo temos gerente e diretor que herdam as caracteristicas de funcionario. E o gerente, o direto e o cliente precisam de alguma função especifica (por exemplo se logar no app). Para resolver isso, criamos uma interface Autenticacao que tem um unico método de fazer login.</p>

<p>Uma classe pode herdar de apenas uma outra classe (isso no PHP e no Java por exemplo). Mas pode implementar quantas interfaces quiser. Então no caso do PHP que não é possível herdar de mais de uma classe, criar interfaces ajuda a resolver esse problema de herança multipla. </p>

<h2>Métodos Mágicos em PHP</h2>

<p>Existem alguns métodos do próprio PHP. Sabemos que são métodos do PHP quando tem dois underscore. Então, por exemplo, o método construtor <code>function __constructor</code>.</p>

<p>Bom, vamos pensar no seguinte. Temos o código abaixo</p>

<p><code>$enderecoEnzo = new Endereco('Rua São João', '30' , 'Centro', 'São Paulo')</code>.</p>

<p>E eu quero exibir esse endereço na tela. A forma mais direta de fazer seria:</p>

<p><code>echo $enderecoEnzo->getCidade() . ', ' . $enderecoEnzo->getBairro() . ', ' . $enderecoEnzo->getRua() . ', ' . $enderecoEnzo->getNumero();</code></p>

<p>Como facilitar isso para não ter que digitar toda hora esse código gigante?</p>

<p>Uma alternativa é dentro da classe endereço criar uma função EnderecoCompleto() com o return acima (sem o echo) e depois digitar apenas <code>echo enderecoEnzo->EnderecoCompleto()</code></p>

<p>Mas existe um jeito ainda mais fácil de fazer isso com métodos mágicos do PHP. E esse é o método toString()</p>

<pre><code [highlight]='codePhp12'></code></pre>

<p>Daria na mesma criar um método EnderecoCompleto() ou o método __toString. A diferença é que com o ToString é só chamar a variável <code>$enderecoEnzo</code> que eu vou receber o retorno da string. Não preciso passar nenhum método</p>

<p>Outra coisa que podemos fazer no php é passar os atributos sem o getters e setters e ainda assim mantendo privado os atributos. Isso é feito através dos métodos mágicos __get e __set.</p>

<h2>Não permitindo heranças</h2>

<p>O PHP pode barrar o uso de herança, caso não queiramos que uma classe seja utilizada em outros lugares usando o <code>final</code></p>

<p><code>final class Endereco ..</code></p>

<p>O <code>final</code> também pode ser utilizado nos métodos e atributos, para não permitir que eles sejam reutilizados em outros lugares.</p>
