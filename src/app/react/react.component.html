<h1>React</h1>

<p class="curiosity"><span class="title-curiosity">Porque o React?</span> Surgiu como uma demanda interna do facebook, em 2011. A ideia era ter uma biblioteca javascript que fosse dinâmica e performática, como de fato acontece com o facebook e o instagram. Em 2013 virou open source e começou a ser utilizado amplamente pelo mercado.</p>

<p>Eu tinha uma experiência anterior em Angular, da versão 4 até a versão 8. E aqui nesse link eu tenho todo o meu aprendizado em Angular</p>

<p>O React é hoje a lib/framework JS mais utilizada. O Angular acabou abarcando mais projetos corporativos (bem robusto e sem tanta indexação e SEO) e o React ficou bastante famoso e utilizado em tudo que é aplicação web.</p>

<p>A partir de julho.2021 comecei a me aprofundar em React, fiz 2 imersões de uma semana e um bootcamp de 3 meses e colocarei aqui as semelhanças e diferenças que eu aprendi com o Angular</p>

<h2>Iniciando nosso projeto</h2>

<p><b>requisitos:</b> Instalar node/yarn</p>

<p><code>yarn create react-app letmeask --template typescript</code></p>

<p>letmeask é o nome do projeto. E o --template typescript é porque queremos utilizar typescript ao invés de JS \o/ .</p>

<p>O <b>Angular</b> já é criado por padrão em Typescript. E isso é muito bom pois o TS é um superset do JS, com tipagem e outros benefícios.</p>

<h2>A estrutura de criação</h2>

<img src="../../assets/estruturaReact.jpg" alt="Estrutura do React">

<p>Temos ali embaixo o <b>.gitIgnore</b> que é do Git. O <b>package.json</b> contendo os pacotes instalados o <b>Readme</b> e <b>tsconfig.json</b> com as configurações do Typescript. Todos eles iguais ao Angular. E temos também o <b>yarn.lock</b>que é um gerador de dependencias do yarn, similar ao package-lock.json do Angular</p>

<p>O <b>node_modules</b> é imensa pasta do Node, que também temos no Angular.</p>

<p>Na hora que instalamos o React, dentro da pasta Public e da pasta Src vem alguns outros arquivos (tipo o logo do react, testes e os arquivos css) que não fazem sentido pra começar o negócio.</p>

<p>Dentro da pasta public tem o <b>index.html</b> que é o arquivo mais comum em qualquer web app</p>

<p>Então as únicas coisas diferentes que tem são os arquivos dentro do 'src'</p>

<p>E a primeira coisa estranha são esses arquivos <b>.tsx</b>. TS é typescript. E o X ? O X é XML. <b>O react</b>, diferente do angular, <b>utiliza o HTML dentro do Javascript</b>. Ou, nesse caso que estamos trabalhando com ts, dentro do Typescript.</p>

<p>Portanto o único html que temos é o index.html dentro do public (o que faz sentido já que o react é estruturado para funcionar como uma SPA). E o index.tsx vai importar as bibliotecas do React, do react-dom (se trabalharmos com app importaria o react-native) e o App que é de onde vai se iniciar nossa aplicação. Seria como o app.component.ts do Angular. </p>

<h2>Outras formas de iniciar projeto com React</h2>

<p>NextJS / Gatsby / CRA</p>

<table class="table table-hover">
  <thead>
    <tr>
      <th scope="col-3">Nome</th>
      <th scope="col-5">Entendendo</th>
      <th scope="col-4">Frameworks</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Static Rendering</td>
      <td>Alguém acessa o site que chama o CDN e retorna um site estático</td>
      <td>Gatsby, VuePress, Gridsome e também o Next.js</td>
    </tr>
    <tr>
      <td>Client Side Rendering (CSR)</td>
      <td>A CDN retorna os scripts/style e depois retorna o Bundle do Javascript e o HTML é renderizado no Browser. Caso precise consumir dados é feita uma chamada via REST API</td>
      <td>React, Angular e Vue</td>
    </tr>
    <tr>
      <td>Universal / Server Side Rendering (SSR)</td>
      <td>Ao acessar a página é feita uma requisição ao servidor. O servidor faz a requisição via REST API, renderiza o HTML no próprio servidor e retorna para o usuário</td>
      <td>Next.js, Nuxt.js e Angular Universal</td>
    </tr>
  </tbody>
</table>

<p>A diferença do Universal Rendering para o Server Side Rendering é que o Universal seria como um mix entre o Client Side e o Server Side. Isso porque no Client Side no qual os 3 famosos frameworks se basearam (React, Angular e Vue) não exigia o carregamos da página  ao navegar (que é o conceito de SPA). Já no modelo do Server Side existia o carregamento. O Universal renderiza tudo no servidor e ao mesmo tempo consegue fazer a navegação sem fazer o reload da página</p>

<p>Tem um melhor? Cada um tem seu trade off. O <b>Static</b> quase não usa o servidor e acaba tendo uma perfomance muito boa. Sites estáticos geralmente carregam muito rápido e tem notas altas no Google Speed Site e outros medidores. Mas o build é lento e as manutenção mais dificeis. Para sites grandes ou que precisam de coisas mais dinamicas (como e-commerce ou noticias), complica. O <b>SPA</b> tem um load inicial mais lento, uma perfomance imprevisível e dificuldades para trabalhar com SEO. Mas como tudo é carregado no browser, a interação é fluida e rápida. o Server Side tem mais perfomance que o SPA, melhor desempenho de SEO e compartilhamento de código com o backend (em Node). Já o TTFB é mais lento (pois o TTFB é o tempo que o browser faz pra buscar algo no servidor. E o servidor precisa estar com tudo pronto). </p>

<h2>Conceitos do React</h2>

<p><b>JSX:</b> JS com HTML no mesmo lugar. E pra confundir um pouco mais, os componentes JS também ficam dentro de tags. Para diferenciar uma da outra, as tags das functions do js são sempre criadas em maiúsculas. <code>&lt;div&gt;</code> é uma tag html e <code>&lt;Div&gt;</code> é uma <code>function Div()</code> do JS.</p>

<p><b>Function x class:</b> A tendência atual do React é usar o paradigma funcional. Isso significa que ao invés de termos classes - como no angular que utilizamos o 'export class...', temos apenas funções em todo o canto do código, utilizando o 'export function'. É possível programar com os dois paradigmas no react e a própria documentação contém as formas e eles dizem que não vão descontinuar a forma de escrever com as classes.

<p><b>Componentes:</b> assim como o angular, tudo no react é um componente. E a junção desses componentes geram as páginas.</p>

<p><b>Propriedades:</b> esse conceito é bem próprio do react. As <code>functions</code> recebem um argumento chamado 'props' (que significa propriedades) e retornam elementos React. Vamos ver um exemplo abaixo:</p>

<pre><code [highlight]='codeReact1'></code></pre>

<p><b>Estado:</b> também é um conceito do react. O state é similar ao props mas é privado e controlado pelo componente. Ainda está confuso pra mim.</p>

<h2>Comandos úteis</h2>

<p><code>yarn start</code> => sobe um servidor local no localhost:3000</p>

<h2>Firebase</h2>

<p><a routerlink="/firebase">Nesse link</a> eu explico um pouco melhor sobre o firebase. Para instalar ele no React é preciso instalar <code>yarn add firebase</code>, depois incluir um arquivo firebase.ts (geralmente na pasta service). Dentro desse arquivo ficam a const firebaseonfig que pego nas configurações de instalação e importo esse servico dentro do index.tsx um <code>import './services/firebase'</code></p>

<h2>Rotas</h2>

<p>Diferente do Angular, precisamos importar um pacote de rotas. O mais famoso é o react-router-dom. E como ele não foi criadao em TS, para dar suporte aos tipos executamos também o <code>@types/react-router-dom -D</code>. O -D é para que crie apenas no ambiente de desenvolvedor (já que o typescript só serve para desenvolvimento. Em produção é js não tipado).</p>

<p>E ai importamos o <code>BrowserRouter, Route</code> dentro da app.tsx </p>

<p>Vai ficar assim:</p>

<pre><code [highlight]='codeReact2'></code></pre>

<h2>Imutabilidade</h2>

<p>Podemos alterar uma variável diretamente ou podemos mudar uma variável criando uma nova.</p>

<pre><code [highlight]='codeReactImutabilidade'></code></pre>

<p>o resultado será o mesmo. Mas então porque utilizar a imutabilidade?</p>

<ul class="list-group list-group-flush">
  <li class="list-group-item">Manter histórico: como no exemplo do jogo da velha, imagina que queremos manter o historico de partidas anteriores para poder criar um arquivo e acessá-los depois. Com a imutabilidade isso fica bem mais fácil de ser feito</li>
  <li class="list-group-item">Detectar mudanças: saber se um objeto mudou, para tomar alguma determinada ação. Com a imutabilidade é facíl, só comparar os dois objetos e ver se tem mudança.</li>
  <li class="list-group-item">re-renderização: no React isso é bastante útil. Quando uma mudança ocorre se torna necessário re-renderizar. E como a imutabilidade torna fácil o processo de perceber as mudanças, re-renderizar fica mais fácil.</li>
</ul>

<h2>Styled Component & props</h2>

<p>Duas coisas que pra mim foram um pouco estranhas para aprender. E as duas juntas ainda mais estranha :)</p>

<p><b>As props</b>, como já falado antes, é um parametro que passamos ao criar um componente nosso. Na verdade, no componente react, é o unico parametro que podemos passar. </p>

<pre><code [highlight]='codeProps1'></code></pre>

<p><b>No Styled Component</b> utilizamos nosso CSS dentro do JS. E nosso CSS passa também a ser um componente (por isso o nome de ´componente de estilo´). Criamos uma váriavel que recebe uma tag html e passamos todo o estilo que quisermos, inclusive com funções e variáveis JS.</p>

<pre><code [highlight]='codeStyledComponent'></code></pre>

<p>Veja como acessamos nossas props no Styled component acima. Temos que passar com uma função que vai receber a props.</p>

<h2>Babel e Webpack (React por trás dos panos)</h2>

<p>O Babel é o responsável por fazer o JS funcionar bem em todos os navegadores. Hoje não percebemos isso com tanto valor, de tão automatico que isso é feito. Antigamente precisava tornar o JS compativel com diferentes navegadores e versões. o Babel resolveu esse problema há um bom tempo. Por exemplo, arrow function de JS não é suportado em um determinado navegador. Ele pega o arrow function e transforma numa function para poder rodar normalmente. Ele também é o responsável pela transpilar código em <b>typescript</b> e em <b>JSX</b> para JS. </p>

<p>Já o webpack é responsável pelos bundles de JS e CSS. Ele faz todo papel de minificação, de uglify e de separar por bundles nossos diversos arquivos JS e CSS para gerar um build mais inteligente.</p>
